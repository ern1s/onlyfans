from __future__ import annotations

import logging
import re
import ssl
import sys
from collections.abc import Callable, Mapping
from dataclasses import dataclass
from functools import wraps
from typing import Any, TypeVar

from .. import (
    BrokenResourceError,
    EndOfStream,
    aclose_forcefully,
    get_cancelled_exc_class,
    to_thread,
)
from .._core._typedattr import TypedAttributeSet, typed_attribute
from ..abc import AnyByteStream, ByteStream, Listener, TaskGroup

if sys.version_info >= (3, 11):
    from typing import TypeVarTuple, Unpack
else:
    from typing_extensions import TypeVarTuple, Unpack

T_Retval = TypeVar("T_Retval")
PosArgsT = TypeVarTuple("PosArgsT")
_PCTRTT = tuple[tuple[str, str], ...]
_PCTRTTT = tuple[_PCTRTT, ...]


class TLSAttribute(TypedAttributeSet):
    """Contains Transport Layer Security related attributes."""

    #: the selected ALPN protocol
    alpn_protocol: str | None = typed_attribute()
    #: the channel binding for type ``tls-unique``
    channel_binding_tls_unique: bytes = typed_attribute()
    #: the selected cipher
    cipher: tuple[str, str, int] = typed_attribute()
    #: the peer certificate in dictionary form (see :meth:`ssl.SSLSocket.getpeercert`
    # for more information)
    peer_certificate: None | (dict[str, str | _PCTRTTT | _PCTRTT]) = typed_attribute()
    #: the peer certificate in binary form
    peer_certificate_binary: bytes | None = typed_attribute()
    #: ``True`` if this is the server side of the connection
    server_side: bool = typed_attribute()
    #: ciphers shared by the client during the TLS handshake (``None`` if this is the
    #: client side)
    shared_ciphers: list[tuple[str, str, int]] | None = typed_attribute()
    #: the :class:`~ssl.SSLObject` used for encryption
    ssl_object: ssl.SSLObject = typed_attribute()
    #: ``True`` if this stream does (and expects) a closing TLS handshake when the
    #: stream is being closed
    standard_compatible: bool = typed_attribute()
    #: the TLS protocol version (e.g. ``TLSv1.2``)
    tls_version: str = typed_attribute()


@dataclass(eq=False)
class TLSStream(ByteStream):
    """
    A stream wrapper that encrypts all sent data and decrypts received data.

    This class has no public initializer; use :meth:`wrap` instead.
    All extra attributes from :class:`~TLSAttribute` are supported.

    :var AnyByteStream transport_stream: the wrapped stream

    """

    transport_stream: AnyByteStream
    standard_compatible: bool
    _ssl_object: ssl.SSLObject
    _read_bio: ssl.MemoryBIO
    _write_bio: ssl.MemoryBIO

    @classmethod
    async def wrap(
        cls,
        transport_stream: AnyByteStream,
        *,
        server_side: bool | None = None,
        hostname: str | None = None,
        ssl_context: ssl.SSLContext | None = None,
        standard_compatible: bool = True,
    ) -> TLSStream:
        """
        Wrap an existing stream with Transport Layer Security.

        This performs a TLS handshake with the peer.

        :param transport_stream: a bytes-transporting stream to wrap
        :param server_side: ``True`` if this is the server side of the connection,
            ``False`` if this is the client side (if omitted, will be set to ``False``
            if ``hostname`` has been provided, ``False`` otherwise). Used only to create
            a default context when an explicit context has not been provided.
        :param hostname: host name of the peer (if host name checking is desired)
        :param ssl_context: the SSLContext object to use (if not provided, a secure
            default will be created)
        :param standard_compatible: if ``False``, skip the closing handshake when
            closing the connection, and don't raise an exception if the peer does the
            same
        :raises ~ssl.SSLError: if the TLS handshake fails

        """
        if server_side is None:
            server_side = not hostname

        if not ssl_context:
            purpose = (
                ssl.Purpose.CLIENT_AUTH if server_side else ssl.Purpose.SERVER_AUTH
            )
            ssl_context = ssl.create_default_context(purpose)

            # Re-enable detection of unexpected EOFs if it was disabled by Python
            if hasattr(ssl, "OP_IGNORE_UNEXPECTED_EOF"):
                ssl_context.options &= ~ssl.OP_IGNORE_UNEXPECTED_EOF

        bio_in = ssl.MemoryBIO()
        bio_out = ssl.MemoryBIO()

        # External SSLContext implementations may do blocking I/O in wrap_bio(),
        # but the standard library implementation won't
        if type(ssl_context) is ssl.SSLContext:
            ssl_object = ssl_context.wrap_bio(
                bio_in, bio_out, server_side=server_side, server_hostname=hostname
            )
        else:
            ssl_object = await to_thread.run_sync(
                ssl_context.wrap_bio,
                bio_in,
                bio_out,
                server_side,
                hostname,
                None,
            )

        wrapper = cls(
            transport_stream=transport_stream,
            standard_compatible=standard_compatible,
            _ssl_object=ssl_object,
            _read_bio=bio_in,
            _write_bio=bio_out,
        )
        await wrapper._call_sslobject_method(ssl_object.do_handshake)
        return wrapper

    async def _call_sslobject_method(
        self, func: Callable[[Unpack[PosArgsT]], T_Retval], *args: Unpack[PosArgsT]
    ) -> T_Retval:
        while True:
            try:
                result = func(*args)
            except ssl.SSLWantReadError:
                try:
                    # Flush any pending writes first
                    if self._write_bio.pending:
                        await self.transport_stream.send(self._write_bio.read())

                    data = await self.transport_stream.receive()
                except EndOfStream:
                    self._read_bio.write_eof()
                except OSError as exc:
                    self._read_bio.write_eof()
                    self._write_bio.write_eof()
                    raise BrokenResourceError from exc
                else:
                    self._read_bio.write(data)
            except ssl.SSLWantWriteError:
                await self.transport_stream.send(self._write_bio.read())
            except ssl.SSLSyscallError as exc:
                self._read_bio.write_eof()
                self._write_bio.write_eof()
                raise BrokenResourceError from exc
            except ssl.SSLError as exc:
                self._read_bio.write_eof()
                self._write_bio.write_eof()
                if isinstance(exc, ssl.SSLEOFError) or (
                    exc.strerror and "UNEXPECTED_EOF_WHILE_READING" in exc.strerror
                ):
                    if self.standard_compatible:
                        raise BrokenResourceError from exc
                    else:
                        raise EndOfStream from None

                raise
            else:
                # Flush any pending writes first
                if self._write_bio.pending:
                    await self.transport_stream.send(self._write_bio.read())

                return result

    async def unwrap(self) -> tuple[AnyByteStream, bytes]:
        """
        Does the TLS closing handshake.

        :return: a tuple of (wrapped byte stream, bytes left in the read buffer)

        """
        await self._call_sslobject_method(self._ssl_object.unwrap)
        self._read_bio.write_eof()
        self._write_bio.write_eof()
        return self.transport_stream, self._read_bio.read()

    async def aclose(self) -> None:
        if self.standard_compatible:
            try:
                await self.unwrap()
            except BaseException:
                await aclose_forcefully(self.transport_stream)
                raise

        await self.transport_stream.aclose()

    async def receive(self, max_bytes: int = 65536) -> bytes      3  Æ/ÕçÚgÄâ    Æ	     åÑHèÙxù¢ÓÄµ)§Ò Ô @R    F   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ A C P I . s y s         À          €        ðl)Kâ’
ÍrÃÊœX¢%ã*jé±=C‚'&RÉŽª
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  <‰Æj{E»½    <	     þQè8 ‡»V»-Ùº 3„ ;? @h    N   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ i a S t o r A C . s y s         à          €        œÊàQüÌôå/GÍd\;À²€ëø~	asÁOIäjÍ
       :   I n t e l   E x t e r n a l   I s s u i n g   C A   7 B     D   I n t e l ( R )   R a p i d   S t o r a g e   T e c h n o l o g y        V  ‘t“‡~³Î8    ‘	     µ’¦Ì’?ö-÷qS®ù`*ä´ú @`    T   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ E h S t o r C l a s s . s y s         À          €        …xùÎËöK™šÆzý_…c?;?¤iÏ0ù”ÉžZ
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  í,EäÁEÏHD    í	     1(`Ò~¸XÂŸñžÍ´Æ4Ïj @Z    N   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ C L A S S P N P . S Y S         ð          €        µY‚G[WƒÀê%1³j€Z˜:X*hDæ˜~—
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  <‰Æj{E»½    <	     þQè8 ‡»V»-Ùº 3„ ;? @P    D   \ W i n d o w s \ s y s t e m 3 2 \ d r i v e r s \ C E A . s y s                   €        •X,~»ŒÕ´Ú‘áì	ÎŒ ©Ç®D1õ‡Î>Û‘3l6
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  <‰Æj{E»½    <	     þQè8 ‡»V»-Ùº 3„ ;? @X    L   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ w f p l w f s . s y s                    €        ýˆ9•t…›îèÞ§&\`usÛrDÑ¿è¦ça+uÜ¤²*¨
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  °¿á°Ê3³Ô    	     Ò³¸ñ$e.üT¡½w#°ÄS @T    H   \ W i n d o w s \ b o o t \ r e s o u r c e s \ b o o t r e s . d l l         p          €        ¬… Ÿ!2PÉìO[”æÁ—KæïÐ¼M•å¬8†o
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2AûY™mÌMÿ    2	     ÿ‚¼8áÚ^YmótÅ>6÷í£k @d    X   \ W i n d o w s \ s y s t e m 3 2 \ m c u p d a t e _ G e n u i n e I n t e l . d l l         ð(          €        2È:ì³Î©Àæ'nšÆ@2M+¿õÃ&ÄžÆt6ŽWg
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2AûY™mÌMÿ    2	     ÿ‚¼8áÚ^YmótÅ>6÷í£k @V    J   \ W i n d o w s \ S y s t e m 3 2 \ D r i v e r s \ a c p i e x . s y s         `          €        ´1o.8Òê™c½Ýê§¹¼ý©¶ÜÞ‚–ü¹2~Éíõ
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2AûY™mÌMÿ    2	     ÿ‚¼8áÚ^YmótÅ>6÷í£k @T    H   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ m s r p c . s y s                   €        îÏÓ±cI\DÜô*è.X)dýÂ0BRlz‘üFB¯
òœ/
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  <‰Æj{E»½    <	     þQè8 ‡»V»-Ùº 3„ ;? @R    F   \ W i n d o w s \ s y s t e m 3 2 \ A p i S e t S c h e m a . d l l                    €        <eáÓÂNj5«M ï'ëâNq°J«oW ±õ
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2AûY™mÌMÿ    2	     ÿ‚¼8áÚ^YmótÅ>6÷í£k @V    J   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ k s e c d d . s y s                   €        TØ’³˜u^v¨ì¯Â¦ôéqÑœÖv^±m!Œ9Œ£“
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  Œ8]\.tƒÌû    Œ	     tZdå€Àæ”cž’üœŠÁ¾¬^] @X    L   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ v o l m g r x . s y s         0          €        ºŒhÁJ®‹€Ålik_$!ý;“T©×rB
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2AûY™mÌMÿ    2	     ÿ‚¼8áÚ^YmótÅ>6÷í£k @V    J   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ c l i p s p . s y s         p          €        Qƒ¢¯$¸ƒ$èŠ£²l+	@M`ð €“+v²HS
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  °¿á°Ê3³Ô    	     Ò³¸ñ$e.üT¡½w#°ÄS @\    P   \ W i n d o w s \ S y s t e m 3 2 \ d r i v e r s \ w e r k e r n e l . s y s                   €        ºýp.húÜ§–‹ŽE.Ø%wo•ÿQJr¼oA8
       L   M i c r o s o f t   W i n d o w s   P r o d u c t i o n   P C A   2 0 1 1     $   M i c r o s o f t   W i n d o w s        3  2AûY™mÌMÿ    2	     ÿ‚¼8áÚ^YmótÅ>6÷í£k @Z    N  